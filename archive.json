{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2023-06-29T01:01:32.303012+00:00",
  "repo": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOJaEkaM5lbyhk",
      "title": "Trust",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/3",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "make it clear that the receiver of the attestation needs to trust the signer of the attestation and pre-obtain(?) the keys to validate it?",
      "createdAt": "2023-05-09T10:10:14Z",
      "updatedAt": "2023-05-21T21:56:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "I would imagine the client is configured/registered with the AS and the jwks or jwks_uri of that client is where the verification keys are found. Basically the trust comes from the client configuration record at the AS (however that comes to be) and the keys are obtained from the client jwks/jwks_uri metadata.",
          "createdAt": "2023-05-10T17:58:41Z",
          "updatedAt": "2023-05-10T17:58:41Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with Brian, I dont think we want this draft to define how the keys required to validate the attestation MUST be obtained because that is really based on how the client comes to be configured at the AS and as a result there could be multiple mechanisms. There may be a need to add some language that makes this clearly however I will note that RFC 7523 doesn't speak to this for the assertions it defines.",
          "createdAt": "2023-05-11T09:54:19Z",
          "updatedAt": "2023-05-11T09:54:19Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "The key point is the digital trust relationship that allows a client to be registered and attestable as realiable and eligible in relation to one or more trust frameworks, and for any following transactions, outside the client registration, that may happen in a defined period of time, beyond which trust with that client must be re-evaluated.\r\n\r\nGiven that having a client registered previously or obtaining its public keys though TLS doesn't give any assurance about the compliance of that client in the present, in relation to privacy and security preserving trust model. We shoudl consider that a client, that's a participant in a Auth/eID infrastructure, may lose its compliance and consequently be banned because of this. The requirement to be met is to allow an automatic method for evaluating the revocation status of the client, if the determining authority (TTP) is outside the party (AS and Client)\r\n\r\nanother key point is that trusted attestations, which allow a customer to be registered and then allow data interchange with it, are considered long-lived attestations, for the satisfaction of non-repudiation requirements for years to come.",
          "createdAt": "2023-05-11T14:49:33Z",
          "updatedAt": "2023-05-11T14:49:33Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "Just to add a bit of context about the comment about RFC 7523 - it doesn't speak to this stuff in specific terms but does have some discussion in [Interoperability Considerations](https://datatracker.ietf.org/doc/html/rfc7523#section-5) that's pretty open ended. RFC7523 came before \"Dynamic Client Registration\" in RFC7591. But since then the metadata defined in RFC7591, and registered extensions to it, have come to imply a general data model for clients that is useful and used for authorization server implementations, even when the Dynamic Client Registration Protocol isn't in play. That includes jwks/jwks_uri metadata as the place for key(s). OIDC core kinda follows and pushes that pattern too and even 'profiles' RFC7591 somewhat with its definition of `private_key_jwt`.  So, regardless of how a client comes to be configured, the jwks or jwks_uri client metadata fields really have become the de facto for where/how client keys are obtained. I think this draft could acknowledge and/or provide some guidance in that direction. The AS would have one client config record for the whole client system and the verification keys for the attestation assertion come from the jwks or jwks_uri fields of that record. \"Trust\" comes from how that client record comes to be configured, but that how is out of scope of this draft. \r\n",
          "createdAt": "2023-05-11T18:28:31Z",
          "updatedAt": "2023-05-18T23:39:21Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I start from the assumption that OpenID Connect Federation confirms the traditional methods to get the jwks, using jwks/jwks_uri, enabling the jwks claim for the openid connect providers metadata as well.\r\n\r\nI want to start from the example below and answering to the question \"How can you trust such client?\"\r\n\r\n````\r\n{\r\n  \"alg\": \"ES256\",\r\n  \"kid\": \"11\",\r\n  \"trust_chain\": [ ... ]\r\n}\r\n.\r\n{\r\n  \"iss\": \"https://client.example.com\",\r\n  \"sub\": \"https://client.example.com\",\r\n  \"nbf\":1300815780,\r\n  \"exp\":1300819380,\r\n  \"cnf\": {\r\n    \"jwk\": {\r\n      \"kty\": \"EC\",\r\n      \"use\": \"sig\",\r\n      \"crv\": \"P-256\",\r\n      \"x\": \"18wHLeIgW9wVN6VD1Txgpqy2LszYkMf6J8njVAibvhM\",\r\n      \"y\": \"-V4dS4UaLMgP_4fY4j8ir7cl1TXlFdAgcx55o7TkcSA\"\r\n    }\r\n  }\r\n}\r\n````\r\n\r\nif we would have a x5c header parameter instead of the Federation Trust Chain, the Key Attestation would be realiable according to a x509 PKI.\r\n\r\nUsing the Federation Trust Chain we are able to:\r\n\r\n- get the public key corresponding to the kid 11\r\n- get the trust relationships between the client and one or more Trusted Third Parties\r\n- get the metadata related to that client (and all its jwks ...)\r\n- get the policy to be applicable to the metadata, following what configured by the Trusted Third Parties for this client\r\n-  verify the trust chain over years, even if the public keys needed for verification are changed to one or multiple trusted third party or in the client as well\r\n\r\nI'm aware that attesting keys is just attesting keys but the model would require how to attest the owner of that key as reliable?\r\nHow do you trust that client, since it has self issued that attestation?\r\n\r\nI suggest to introduce the topic of Trust Establishment in this Draft, to give some pointers or refs to the ways we have todate to verify the reliability of an attestation, since a self-signed attestation is not attestable as secure.\r\n\r\nAt the same time there may be the possibility that a client attestation should be issued by a trusted third party, so the question would are: \r\n\r\n- Is there a single Trusted Third Party? \r\n- Is there any way the Trusted Third Party has to delegate the issuing of the attestations to another party as an intermediate?\r\n- Is there the need to obtain the public keys of all the Trusted Third Parties, if more than a single? If yes, how to know who these are?\r\n\r\nI'm asking since I found these answers in OpenID Connect Federation and the questions above are the classical questions the analysts/implementers have when deals with client attestations or dynamic client registrations ",
          "createdAt": "2023-05-20T17:01:34Z",
          "updatedAt": "2023-05-20T22:56:42Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "Another example to exemplify the differences bwtween key attestation and assurance of reliability. \r\n\r\nA crypto key Is a key Just as a Key of a hotel room\r\n\r\nGiven that that Key effectively works for its hotel room, the question Is: which reputation has that hotel?\r\nHow many \"stars\" does It have?\r\nWho give those \"stars\"?\r\nWhich are the evaluation parameters and for how long  will these be valid?\r\nWill be a day when the hotel owner may say to have never give that room to a client, or that such client was never seen before?\r\nWhich trust framework will protect both hotel owner and client from unwanted actions they may do against each other?\r\n\r\nassurance of reliability is something verifiable, even If I'm aware that Trust is more a strategy and the Trust Model should define the rules and the architectural components to implement this strategy. A Strategy won't give us the assurance that a bad action won't be made by an Entity but at the same time the model must give also the assurance that every proof must be non repudiable and issued as long-lived, to give the guarantee to the participants that even if a rogue participant will break the rules of the trust, the proofs will be always verifiable in the future (especially when public keys will change)",
          "createdAt": "2023-05-21T21:55:39Z",
          "updatedAt": "2023-05-21T21:56:17Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOJaEkaM5l2HJe",
      "title": "`sub` value",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/4",
      "state": "OPEN",
      "author": "Sakurann",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The text currently says:\r\n> The JWT MUST contain a \"sub\" (subject) claim with a value corresponding to the \"client_id\" of the OAuth client.\r\n\r\nthe thing is.. when there could been no pre-existing relationship between the issuer and the wallet. probably worth noting that `sub` (and `client_id` value) can be self-attested by the wallet frontend",
      "createdAt": "2023-05-13T16:58:41Z",
      "updatedAt": "2023-06-05T16:12:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I dont think we want to offer too much commentary here about how the client ends up with a client ID that is recognised and trusted by the AS (credential issuer), but I agree the case you raise is permitted.",
          "createdAt": "2023-05-14T23:47:44Z",
          "updatedAt": "2023-05-14T23:47:44Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Shouldn't we at least describe what identifier is used for further processing (whether to lookup further data or in audit logs)? If the AS trusts the Issuer of the JWT, it should trust it to put a reasonable value in the `sub` field for further usage. ",
          "createdAt": "2023-05-16T13:49:05Z",
          "updatedAt": "2023-05-16T13:49:05Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I assume in some cases the issuer will out the `iss` in the `sub` claim, i.e. whatever data is looked up will be about the issuer (e.g. a wallet provider).",
          "createdAt": "2023-05-16T13:50:03Z",
          "updatedAt": "2023-05-16T13:50:03Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Apologies im not following you here, I'm inclined to make the iss the client ID as I think the most common case here is that its the client attesting a client instance and make the sub value a client instance ID that is unique per authorization server.",
          "createdAt": "2023-05-18T07:00:03Z",
          "updatedAt": "2023-05-18T07:00:03Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How have you come to the conclusion that this is the most common case?\r\n\r\nMy rationale is as follows: if the issuer wants to client id to be the iss value, it puts the iss value in the sub. If the issuer wants the client id to be something else, it uses a different value. I don\u2019t see a need for a client instance identification (at all or as default).",
          "createdAt": "2023-05-18T07:08:33Z",
          "updatedAt": "2023-05-18T07:08:54Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> How have you come to the conclusion that this is the most common case?\r\n\r\nI think the most common party signing the client attestation will be the client itself (e.g the backend component), as the AS will need to be able to relate the attestation keys back to the client in order to trust it any way. Do you have usecases where the attester is not the client, I believe this model is complex and we should seriously consider whether we support it. If the attester isn't the client then what do you set the iss value to, what does it mean and how should it influence validation of the attestation?",
          "createdAt": "2023-05-18T08:27:19Z",
          "updatedAt": "2023-05-18T08:28:37Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In general, I would assume the provider of the client to sign the attestation. However, Bundesdruckerei has implemented as solution where the attestation is issued by a trusted 3rd party. \n\nWith respect to the spec: I think it doesn't matter who signs the attestation as long as the AS trusts that party.",
          "createdAt": "2023-05-18T08:41:44Z",
          "updatedAt": "2023-05-18T08:41:44Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that in effect a trusted 3rd party could do the signing, however I dont believe their identity should be known to the AS (e.g as another protocol participant) instead their identity should still be considered part of the client.",
          "createdAt": "2023-05-18T09:41:38Z",
          "updatedAt": "2023-05-18T09:41:38Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why?",
          "createdAt": "2023-05-18T10:43:02Z",
          "updatedAt": "2023-05-18T10:43:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm unsure that it provides any value having another identified participant in the protocol seperate from the client. Can you elaborate on the value of why this trusted third party needs be independently identifiable from the client to the AS? How would its identity become know and managed by the AS?",
          "createdAt": "2023-05-18T10:47:20Z",
          "updatedAt": "2023-05-18T10:47:57Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Again. As long as the AS trusts the issuer of the assertion, it can accept it. I don\u2019t think we need to specify more than that + the sub is the client id. That\u2019s sufficient for interoperability.\n\nTo the contrary, I don\u2019t see a benefit in limiting the issuer to \u201ethe client\u201c.\nOn 18. May 2023 at 12:47 +0200, Tobias Looker ***@***.***>, wrote:\n> I'm unsure that it provides any value having another participant in the protocol seperate from the client. Can you elaborate on the value of why this trusted third party needs be independently identifiable from the client to the AS? How would its identity become know and managed by the AS?\n> \u2014\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> You are receiving this because you commented.Message ID: ***@***.***>\n",
          "createdAt": "2023-05-18T10:51:28Z",
          "updatedAt": "2023-05-18T10:51:28Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree the most common use case is the iss being the client backend but we should not limit ourselves here.\nI propose iss is the attestation service and sub is a common name for the client aka wallet solution.\nIn some cases both might be the same but they don't need to be.\nBoth identifiers might be relevant for a lookup in a trust list ",
          "createdAt": "2023-05-18T11:08:02Z",
          "updatedAt": "2023-05-18T11:08:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Understood but I disagree, how does the attestation service become registered with the AS and managed beyond this point e.g in the event of key rotation, we would be adding another entirely new protocol participant for OAuth2 and I'm not sure we've identified any use cases where this would be valuable. Having the attestation service independently identified to the AS would only appear to be valuable when more than one client deployment wants to use the same attestation service, how common is that pattern? Because if we believe its not very common then the most common case where attestation service == client will likely pay a cost of increased complexity. Also what are the implications on the trust model for the AS, when things go wrong in which situations does it blame the client and others when it blames the attestation service?",
          "createdAt": "2023-05-18T19:46:46Z",
          "updatedAt": "2023-05-18T19:46:46Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How and why the AS trusts the issuer of an attestation is out of scope since it is not relevant on the protocol level. We also haven't defined this in the high assurance profile between verifier and issuer of a VC. I don't understand why we should take a different route here.\n\nJust as an example:\nIn the EU, the issuer will be maintained in a trusted list all issuers trust.\nIn a closed deployment, I would assume the trusted attestation issuers are directly maintained at the issuer.\n\nMany ways to get to Rome. We don't need to know all of them, just cater for them.",
          "createdAt": "2023-05-18T19:56:20Z",
          "updatedAt": "2023-05-18T19:56:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "> How and why the AS trusts the issuer of an attestation is out of scope since it is not relevant on the protocol level\r\n\r\nOk I think perhaps our disconnect is here, how can the notion of \"the attestation service\" be entirely out of scope of this protocol? Its a party to the protocol who's identity will be crucial in the AS making a trust decision. Do we not need to define at least that the iss value of the client attestation IS an identifier for the attestation service and also how you resolve its keys and manage it in lifecycle? Also as I said before I think giving the AS two things to trust in reference to a client enormously increases the complexity in the trust decision it must make. ",
          "createdAt": "2023-05-18T20:09:49Z",
          "updatedAt": "2023-05-18T20:09:49Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Are all of those details defined in RFC 7523? I don't think so. This a base spec that is further detailed in profiles and deployments. The vc-sd-jwt spec s add also doesn't require a certain key resolution method for the same reason.\nIt doesn't matter for this spec whether the JWT is issued by a client backend or any other source. Important is that the AS needs to trust this issuer and that this JWT issuer determines the sub value, which is the client id. Anything beyond is subject to other specs in my opinion.\nFor the high assurance profile, I would assume keys are resolved either web based or with x509, like for the VCs. Other profiles can do it differently.",
          "createdAt": "2023-05-18T20:54:48Z",
          "updatedAt": "2023-05-18T20:54:48Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Right but RFC 7523 also doesn't formally define a new protocol participant either that the AS must trust independent of the client, instead its implied the keys required to verify the client attestation are associated to the client which is the model I'm proposing we recognise more formally. Are there any deployments of RFC 7523 that exist where the iss value in the assertion is not in some way an identifier for the client?",
          "createdAt": "2023-05-18T21:17:32Z",
          "updatedAt": "2023-05-18T21:17:49Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Something that was also pointed out to me is that RFC7523 may not require the iss to be the client_id but OpenID's profiling of it [did](https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication) and from what I understand there was no particular reason for RFC7523 to not constrain the iss value in this way, it just didn't. Nor are there really any deployments that have used RFC7523 in a way where the iss value is not the client id. ",
          "createdAt": "2023-05-19T00:43:33Z",
          "updatedAt": "2023-05-19T00:43:33Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "here I share something that emerged during the implementations and comparisons that took place with other analysts\r\n\r\niss and sub should not contain the same value, since the wallet provider (iss) is a separate entity with respect to the wallet instance (sub)\r\n\r\nFor this reason iss and sub must contain different identifiers, being related to distinct entities.\r\n\r\nThere are some cases where the client should not have a unique identifier, in this case the sub claim should not be included in the claim, because having iss and sub with identical values \u200b\u200bwould not make sense.\r\n\r\nFor this reason I propose to make the sub claim OPTIONAL rather than REQUIRED (MUST).",
          "createdAt": "2023-06-05T08:30:49Z",
          "updatedAt": "2023-06-05T08:30:49Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> iss and sub should not contain the same value, since the wallet provider (iss) is a separate entity with respect to the wallet instance (sub)\r\n\r\nWhy is that and what did emerge during implementations?",
          "createdAt": "2023-06-05T08:33:36Z",
          "updatedAt": "2023-06-05T08:33:36Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the discussion goes somewhere else now.\n\nOriginally the question was whether the attesting entity must be the client backend or can be a trusted third party.",
          "createdAt": "2023-06-05T11:07:53Z",
          "updatedAt": "2023-06-05T11:07:53Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "> Why is that and what did emerge during implementations?\r\n\r\nexactly was I wrote in the thread\r\n\r\n\r\n",
          "createdAt": "2023-06-05T12:25:14Z",
          "updatedAt": "2023-06-05T12:25:14Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess you mean \"iss and sub should not contain the same value, since the wallet provider (iss) is a separate entity with respect to the wallet instance (sub)\"\r\n\r\nWhile I agree on a conceptual level, I don't follow your conclusion that that an attestation needs to have different values for iss and sub. From the issuer's standpoint it is important to know it is talking to an instance of the respective wallet provider/product. It does not need to have an identity/identifier, nevertheless. You seem to agree as you propose to make the sub optional. Why do you think this is the better option than using sub == iss (i.e. self asserted, which to me makes sense). ",
          "createdAt": "2023-06-05T14:14:14Z",
          "updatedAt": "2023-06-05T14:14:34Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "I got your point.\r\n\r\nI don't think that iss == sub because the wallet provider attests this to the wallet instance as a personal mobile device.\r\nThere might be some cases where the wallet instance is provided as a cloud service, thus this would be a specialized case compatible to your vision.\r\n\r\nIn the cases where the wallet instance is a personal device, the Wallet Instance Attestation is not self-asserted since Provider and Instance are actually different entities. The issuer attests information in possession and control of the instance, that's a distinct entity under the sole control of the user.\r\n\r\nIf the attestation is self asserted the private key should be in control of the wallet provider, while this is not the case where personal device are involved.\r\n\r\nthe wallet provider doesn't have any control on the private keys and general details of the wallet instance, since these are arbitraries\r\n\r\n",
          "createdAt": "2023-06-05T16:10:57Z",
          "updatedAt": "2023-06-05T16:12:37Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDOJaEkaM5mDAKH",
      "title": "Change name of the JWT to Client Attestation ",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/6",
      "state": "OPEN",
      "author": "tlodderstedt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm struggling with the terminology currently used in this draft. For me, it describes a mechanism to use JWTs to authenticate OAuth clients. \r\n\r\nHowever, the draft currently designates those JWTs as \"Key Attestation\" or \"attestation key\" or \"jwt-key-attestation\", which sounds like the focus is on attesting something about a certain key to the AS. But that's obviously not the case since, this draft is about client authentication and the key is \"just\" used to protect the JWT against replay. \r\n\r\nI think the name is confusing and suggest to change it to \"Client Attestation\". ",
      "createdAt": "2023-05-16T13:45:01Z",
      "updatedAt": "2023-06-05T14:08:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed, what about \"Client Attestation based Client Authentication\" as a draft title?",
          "createdAt": "2023-05-18T06:55:37Z",
          "updatedAt": "2023-05-18T06:55:52Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I revisited the title of RFC 7523. What about \u201eSender-Constrained JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication\u201c?",
          "createdAt": "2023-05-18T07:24:52Z",
          "updatedAt": "2023-05-18T07:24:52Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "@tlodderstedt thats a proposal for the title of the RFC I guess? I'm ok with that..\r\nI propose \"Client Attestation JWT\" for the actual thing, that we call wallet attestation in our scenario",
          "createdAt": "2023-05-19T16:27:53Z",
          "updatedAt": "2023-05-19T16:27:53Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Renaming the Client Attestation covered by #11 .\r\nRenaming topic in this issue is about the title?",
          "createdAt": "2023-05-22T16:22:45Z",
          "updatedAt": "2023-05-22T16:22:45Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "After thinking about this more I propose \"Attestation Based Client Authentication for OAuth 2\"",
          "createdAt": "2023-05-30T21:47:55Z",
          "updatedAt": "2023-05-30T21:47:55Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What is the meaning of this title? What does \"Attestation based\" mean?",
          "createdAt": "2023-05-31T01:21:47Z",
          "updatedAt": "2023-05-31T01:21:47Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "that the Client backend/Attestation Service attests the Client Instance",
          "createdAt": "2023-06-05T13:24:21Z",
          "updatedAt": "2023-06-05T13:24:21Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How is that different from \"JWT-based client authentication\"? The JWT also contains claims about the client.",
          "createdAt": "2023-06-05T14:08:44Z",
          "updatedAt": "2023-06-05T14:08:44Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOJaEkaM5mMD6N",
      "title": "Introduction text",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/7",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft says:\r\n\r\n> [[RFC7521](https://vcstuff.github.io/draft-looker-oauth-attested-key-based-client-authentication/draft-looker-oauth-attested-key-based-client-authentication.html#RFC7521)] defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate it self with the authorization server through an attested key based authentication scheme.\r\n\r\nI don't like the description of a \"an attested key based authentication scheme\", as key attestations are not always possible and it is more about attesting the wallet and the key being a mechanism.\r\n\r\n I would rather describe the current approach as a\r\n- remote client (instance) attestation scheme\r\n- remote wallet (instance) attestation scheme",
      "createdAt": "2023-05-17T18:27:28Z",
      "updatedAt": "2023-05-22T16:21:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed I dont like it particularly either, what about just \r\n\r\n\r\n[[RFC7521](https://vcstuff.github.io/draft-looker-oauth-attested-key-based-client-authentication/draft-looker-oauth-attested-key-based-client-authentication.html#RFC7521)] defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate itself with the authorization server through an attestation based authentication scheme.",
          "createdAt": "2023-05-18T06:54:25Z",
          "updatedAt": "2023-05-18T06:54:39Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm fine to close this, see #11 ",
          "createdAt": "2023-05-22T16:21:37Z",
          "updatedAt": "2023-05-22T16:21:37Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOJaEkaM5mMRNY",
      "title": "Improvements to the diagram",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/8",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current diagram describes 6 steps:\r\n(1) Generate Attestation Key \r\n(2) Request  Client Key Attestation for generated key\r\n(3) Generate Client Key Attestation\r\n(4) Repond with Generated Client Key Attestation\r\n(5) Generate Key Attestation PoP\r\n(6) Interaction using Client Key Attestation + PoP for authentication\r\n\r\nI would propose for:\r\n(1) Generate key and client app attestations\r\n(2) Request Client Attestation JWT\r\n(3) Validate attestations and generate Client Attestation JWT\r\n(4) Issue Client Attestation JWT\r\n(5) Generate DPoP for Client Attestation JWT\r\n(6) Authenticate using Client Attestation JWT + DPoP\r\n",
      "createdAt": "2023-05-17T18:59:35Z",
      "updatedAt": "2023-05-22T16:20:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple of thoughts w.r.t this\r\n\r\nIm not sure how much we want to talk about app attestations in this draft as it assumes the client instance is say a native app.\r\n\r\nI think this issue has some good terminology suggestions WDYT about the following\r\n\r\nClient Attestation JWT - Generated by the client backend\r\nClient Instance PoP JWT - Generated by the client instance during client authentication (I dont think DPoP is right to use here w.r.t how it conflicts with DPoP)\r\nClient Instance Key - What the client attestation jwt is bound to\r\n\r\n",
          "createdAt": "2023-05-18T06:52:53Z",
          "updatedAt": "2023-05-18T06:52:53Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, is this covered by #11 ?\r\nOk to close for me",
          "createdAt": "2023-05-22T16:20:31Z",
          "updatedAt": "2023-05-22T16:20:31Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOJaEkaM5mPkLA",
      "title": "Replay attack prevention through AS contributed nonce",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/9",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the specification does not define a mechanism for an AS contributed nonce to feature in the client attestation PoP meaning replay attack detection by authorisation servers requires tracking the JTI within the time window set by the PoP's iat claim. We should elaborate on an AS contributed nonce for the specification.",
      "createdAt": "2023-05-18T10:00:50Z",
      "updatedAt": "2023-05-23T19:28:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "What about using the authorization code or pre auth code as suggested in our demo?",
          "createdAt": "2023-05-18T11:03:02Z",
          "updatedAt": "2023-05-18T11:03:02Z"
        },
        {
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is an option, however the nonce for client authentication becomes dependent on the grant type which creates a bit of an awkward coupling when an application wants to say use this mode of client authentication for grant type other than pre auth code or authorisation code.",
          "createdAt": "2023-05-18T20:35:12Z",
          "updatedAt": "2023-05-18T20:35:35Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "How many implemantations out there actually use different grant types than auth-code?\r\nGiven that this serves our purposes and imo everybody is using auth-code, I think that we should RECOMMEND that scenario but I#m ok with showing up alternatives as you suggested.\r\n@tlodderstedt What's your opinion on this?",
          "createdAt": "2023-05-22T16:13:22Z",
          "updatedAt": "2023-05-22T16:13:22Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the flow can be used with and without nonce. \r\n\r\nIf it is used without nonce, jti and short expiration must be used to limit the risk. \r\nIf a nonce is used, I think using the codes is a pragmatic option. Alternatively, the AS could provide a dedicated nonce with the credential offer or authorization response. It could also provide the nonce with a token error response. ",
          "createdAt": "2023-05-23T07:35:49Z",
          "updatedAt": "2023-05-23T07:35:49Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "discussion on 23.05 is leaning towards DpoP-style error providing nonce",
          "createdAt": "2023-05-23T19:28:50Z",
          "updatedAt": "2023-05-23T19:28:50Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOJaEkaM5mhKRe",
      "title": "Explain and discuss the options of ad-hoc and long-lasting client attestations",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/10",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Options on requesting/generating the client/wallet attestation ad-hoc or in advance have been discussed and there are pros and cons for both sides. Is a short explanation of this suited for the RFC?",
      "createdAt": "2023-05-22T15:52:23Z",
      "updatedAt": "2023-05-22T15:52:23Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOJaEkaM5nOgXk",
      "title": "Why not just use the same client attestation JWT? That would not require any client instance identification and is also not a privacy issue.",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/12",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "              Why not just use the same client attestation JWT? That would not require any client instance identification and is also not a privacy issue. \r\n\r\nurn:ietf:params:oauth:client-assertion-type:jwt-key-attestation -> urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation\r\n\r\n_Originally posted by @tlodderstedt in https://github.com/vcstuff/draft-looker-oauth-attested-key-based-client-authentication/pull/11#discussion_r1201683953_\r\n            ",
      "createdAt": "2023-05-30T09:15:06Z",
      "updatedAt": "2023-05-30T09:15:06Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 13,
      "id": "I_kwDOJaEkaM5nQFkc",
      "title": "Client Key Attestation JWT Example",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/13",
      "state": "OPEN",
      "author": "fmarino-ipzs",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the example in section 3.1.1. the issuer and the sub parameters should not be the same since the Wallet provider and the wallet instance are distinct entities. The private key in sole control of the wallet instance is referenced in the attestation while the subject refers to the Wallet Provider. \r\n\r\nMoreover, is the given example meant to be normative? I'm asking since in the example we find the JWS header parameter kid without any explanatory text about the key resolution mechanism allowed in the specs. (x5c, trust_chain, jwk)\r\n\r\n",
      "createdAt": "2023-05-30T13:22:00Z",
      "updatedAt": "2023-05-30T13:22:00Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 14,
      "id": "I_kwDOJaEkaM5nQJz8",
      "title": "The Entity Attestation Token (EAT)",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/14",
      "state": "OPEN",
      "author": "peppelinux",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Is there any considerations about adopting *The Entity Attestation Token (EAT)* [draft-ietf-rats-eat-12](https://datatracker.ietf.org/doc/draft-ietf-rats-eat/12/) for the Attestation JWT?",
      "createdAt": "2023-05-30T13:31:55Z",
      "updatedAt": "2023-05-30T13:31:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 15,
      "id": "I_kwDOJaEkaM5nQSkv",
      "title": "Security levels in the attestation",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/15",
      "state": "OPEN",
      "author": "fmarino-ipzs",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Since the EUDI Wallet instance may have different level of security depending on its own hardware and/or software capabilities, here the proposal: define a claim name for exposing different level of security of the wallet instance.\r\n\r\nExample:\"gold\", \"silver\" and \"bronze\" or \"high\", \"medium\", \"low\" depending on the framework used. \r\n\r\nThis proposal enables the security evaluation to the credential issuing side (or any other Relying Party) without knowing any specific hardware or software features (e.g. OS, etc.). ",
      "createdAt": "2023-05-30T13:52:15Z",
      "updatedAt": "2023-06-17T12:47:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "The RFC may be used to issue wallet attestations in the eIDAS use case, giving additional information on the key type of the `cnf` and the user authenticaiton mechanisms, see more info [here](https://www.linkedin.com/feed/update/urn:li:activity:7056179875635724289/). A Wallet alone does not achieve a LoA but only supports the issuer in achieving an LoA for the lifecycle of an issues credential. However, a claim `supported_LoA` could be useable",
          "createdAt": "2023-05-30T15:18:52Z",
          "updatedAt": "2023-05-30T15:18:52Z"
        },
        {
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "body": "Here the proposal raised in the italian implementation\r\n\r\n`asc_values_supported` and `asc`\r\n\r\nwhere ASC is the acronym of Attested Security Context\r\n\r\nthis aims do disambiguate the meaning of LoA, that is referred to person identities, to the scope of this attestation, that's entirely related to the security context of a personal device \r\n\r\n#### asc_values_supported\r\n\r\nis a capability of the wallet provider, that defines which kind of checks/levels is able to attests to its wallet instances\r\n\r\n#### asc \r\n\r\nis the claim issued in the Wallet Instance Attestation",
          "createdAt": "2023-06-17T12:46:20Z",
          "updatedAt": "2023-06-17T12:47:50Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOJaEkaM5nyl4B",
      "title": "Reanme Grant Type to JWT-PoP?",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/17",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Issue raised by Kristina:\r\nI also perceive this draft as a PoP version of urn:ietf:params:oauth:grant-type:jwt-bearer, would it make sense to make that more intuitive and explicit - like urn:ietf:params:oauth:grant-type:jwt-pop? - this can be another issue\r\n\r\n_Originally posted by @Sakurann in https://github.com/vcstuff/draft-looker-oauth-attested-key-based-client-authentication/pull/11#pullrequestreview-1451679914_\r\n            ",
      "createdAt": "2023-06-05T08:59:41Z",
      "updatedAt": "2023-06-05T08:59:41Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 18,
      "id": "I_kwDOJaEkaM5oo1Wx",
      "title": "client_assertion_type",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/18",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "              I perceive this draft as a PoP version of `urn:ietf:params:oauth:grant-type:jwt-bearer`, would it make sense to make that more intuitive and explicit - like `urn:ietf:params:oauth:grant-type:jwt-pop`?\r\n\r\n_Originally posted by @Sakurann in https://github.com/vcstuff/draft-looker-oauth-attested-key-based-client-authentication/pull/11#discussion_r1210728395_\r\n            ",
      "createdAt": "2023-06-13T19:34:04Z",
      "updatedAt": "2023-06-13T19:34:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 20,
      "id": "I_kwDOJaEkaM5pQ52B",
      "title": "Change Client Attestation JWT to SD-JWT",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/20",
      "state": "OPEN",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If we use SD-JWT instead of JWT for Client Attestation, things might be easier and its a good test case for using SD-JWT without Disclosures",
      "createdAt": "2023-06-20T19:38:28Z",
      "updatedAt": "2023-06-20T19:38:28Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOJaEkaM5p9Z-V",
      "title": "Terms and Definitions are run together",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/issues/24",
      "state": "OPEN",
      "author": "selfissued",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the Terminology section, the term names and term definitions are run together with no punctuation between them.  For example:\r\n> Client Attestation JWT A JSON Web Token (JWT) generated by the client backend which is bound to a key managed by a client instance which can then be used by the instance for client authentication.\r\n\r\nI suggest emulating the formatting in https://openid.bitbucket.io/connect/openid-4-verifiable-credential-issuance-1_0.html#name-terminology.",
      "createdAt": "2023-06-27T20:29:52Z",
      "updatedAt": "2023-06-27T20:29:52Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOJaEkaM5P0e5x",
      "title": "Various editorial updates",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/pull/1",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The following changes are encapsulated in this PR:\r\n\r\n- Update references from RFC7523 to RFC7521.\r\n- Added a recommendation around order of validation for the two JWTs in the client_assertion parameter.\r\n- Removed the note from the exp and iat claims for the client key Attestation JWT that imply this cannot be re-used across multiple requests.\r\n- Removed the ability to use MAC based algorithms when producing the client key Attestation JWT.\r\n- Updated the requirements around the presence of the JTI claim for the client key attestation PoP to be a MUST inline with DPoP PoPs for reliable basic replay attack detection mechanism.\r\n- Added references to the JWT RFC.\r\n- Added an implementation consideration that highlights a client instance can re-use a client key attestation JWT in multiple AS interactions/requests.\r\n- Added aud as a required claim in the client attestation pop JWT.\r\n- Add IANA registration request for the new client assertion type and token endpoint authentication method.",
      "createdAt": "2023-05-04T22:52:22Z",
      "updatedAt": "2023-05-07T20:13:02Z",
      "baseRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "baseRefName": "main",
      "baseRefOid": "f84b4b49034eca55f9546d11bbbe0a8657b00b86",
      "headRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "tl/editorial-updates",
      "headRefOid": "5e5a37dd4f2f5acbc11cb543a517d35a35ce49e0",
      "closedAt": "2023-05-07T20:13:02Z",
      "mergedAt": "2023-05-07T20:13:02Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "fcfa55cd1a986edd8c6438b6eee72aeeeea1e91e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOJaEkaM5QCK17",
      "title": "Add refresh token binding implementation consideration and update broken links",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/pull/2",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed over email, this PR drafts some text to capture the requirement around refresh token binding to the client instance not just the client. The PR also addresses some broken links.\r\n\r\nPersonally I'm still not convinced that the best way to do this binding is through the client attestation key, instead I think we could add a claim that identifies the client instance in the client key attestation",
      "createdAt": "2023-05-08T20:25:40Z",
      "updatedAt": "2023-05-11T19:18:01Z",
      "baseRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "baseRefName": "main",
      "baseRefOid": "fcfa55cd1a986edd8c6438b6eee72aeeeea1e91e",
      "headRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "tl/editorial-updates",
      "headRefOid": "525896663b6a46b83e5bba8a3902076add25569c",
      "closedAt": "2023-05-11T19:17:49Z",
      "mergedAt": "2023-05-11T19:17:49Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "a9c23810d7ebbe6131fc9dd944aecae0d0d9267d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5UqJWv",
          "commit": {
            "abbreviatedOid": "e9cb956"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "few suggestions",
          "createdAt": "2023-05-10T10:39:22Z",
          "updatedAt": "2023-05-10T10:40:33Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "```suggestion\r\n# The OAuth 2.0 Attested Key Based Client Authentication\r\n```",
              "createdAt": "2023-05-10T10:39:22Z",
              "updatedAt": "2023-05-10T10:40:33Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThis is the working area for the individual Internet-Draft, \"The OAuth 2.0 Attested Key Based Client Authentication\".\r\n```",
              "createdAt": "2023-05-10T10:39:34Z",
              "updatedAt": "2023-05-10T10:40:33Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nAuthorization servers issuing a refresh token in response to a token request using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" client authentication method MUST bind the refresh token to the client instance, and NOT just the client as specified in section 6 [@!RFC6749]. To prove this binding, the client instance MUST authenticate itself to the authorization server when refreshing an access token using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" authentication method. The client MUST also use the same client attestation key that was used for authentication when the refresh token was issued.\r\n```",
              "createdAt": "2023-05-10T10:40:25Z",
              "updatedAt": "2023-05-10T10:40:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5UtDqu",
          "commit": {
            "abbreviatedOid": "e9cb956"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T17:26:36Z",
          "updatedAt": "2023-05-10T17:26:36Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Don't think we want an article here \"The\" as a start of the title. Also 2.0 is problematic in a world where 2.1 will soon be a thing.",
              "createdAt": "2023-05-10T17:26:36Z",
              "updatedAt": "2023-05-10T17:26:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5UtDtb",
          "commit": {
            "abbreviatedOid": "e9cb956"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-10T17:26:43Z",
          "updatedAt": "2023-05-10T17:26:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "As above",
              "createdAt": "2023-05-10T17:26:43Z",
              "updatedAt": "2023-05-10T17:26:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOJaEkaM5Ql_Wl",
      "title": "Add privacy consideration around client instance tracking",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/pull/5",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As highlighted in the title this PR adds a privacy consideration around potential client instance tracking along with a recommendation for client deployments to mitigate such risk.",
      "createdAt": "2023-05-16T09:17:09Z",
      "updatedAt": "2023-05-17T06:46:06Z",
      "baseRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "baseRefName": "main",
      "baseRefOid": "a9c23810d7ebbe6131fc9dd944aecae0d0d9267d",
      "headRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "tl/client-instance-tracking",
      "headRefOid": "1d0783734cbc31749dbe529159351dddefa679e7",
      "closedAt": "2023-05-17T06:38:14Z",
      "mergedAt": "2023-05-17T06:38:14Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "071f2a30565a4428394ab157325fffd212a47277"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5VJsLR",
          "commit": {
            "abbreviatedOid": "2390ceb"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-16T13:35:52Z",
          "updatedAt": "2023-05-16T13:35:52Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nImplementers should be aware that using the same client attestation across multiple authorization servers could result in correlation of the end user using the client instance through claim values (including the public key in the `cnf` claim). Client deployments are therefore RECOMMENDED to use different client attestations across different authorization servers.\r\n```",
              "createdAt": "2023-05-16T13:35:52Z",
              "updatedAt": "2023-05-16T13:35:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5VOrvQ",
          "commit": {
            "abbreviatedOid": "1d07837"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-17T06:33:55Z",
          "updatedAt": "2023-05-17T06:33:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "PR_kwDOJaEkaM5RCLU9",
      "title": "Introduction Text + Renaming Client Key Attestation to Client Attestation",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/pull/11",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-22T16:08:04Z",
      "updatedAt": "2023-06-13T19:46:10Z",
      "baseRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "baseRefName": "main",
      "baseRefOid": "071f2a30565a4428394ab157325fffd212a47277",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "main",
      "headRefOid": "8825f3f2ea5483d053892c8da6b23e5c3ad8acec",
      "closedAt": "2023-06-13T19:46:10Z",
      "mergedAt": "2023-06-13T19:46:10Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "0d942cf0688ed99afccfb16c850bb5ff7b62bfc3"
      },
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Please change file/draft name and title, too. ",
          "createdAt": "2023-05-23T07:33:18Z",
          "updatedAt": "2023-05-23T07:43:03Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> \r\n> I also perceive this draft as a PoP version of urn:ietf:params:oauth:grant-type:jwt-bearer, would it make sense to make that more intuitive and explicit - like urn:ietf:params:oauth:grant-type:jwt-pop? - this can be another issue\r\n\r\nOpened as a separate issue.",
          "createdAt": "2023-06-05T09:04:28Z",
          "updatedAt": "2023-06-05T09:04:28Z"
        },
        {
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "body": "> a new paragraph in intro sectionis great but hard to follow, suggest to break it down into steps and put under the diagram.\r\n\r\n@Sakurann please check my latest suggestion\r\n",
          "createdAt": "2023-06-05T09:32:55Z",
          "updatedAt": "2023-06-05T09:32:55Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5VwwSj",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-23T07:25:58Z",
          "updatedAt": "2023-05-23T07:32:48Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate itself with the authorization server through an assertion that is sender-constrained with a public key, i.e. the client must present the assertion along with a proof of possession for that public key. \r\n```",
              "createdAt": "2023-05-23T07:25:58Z",
              "updatedAt": "2023-05-23T07:32:48Z"
            },
            {
              "originalPosition": 14,
              "body": "what is an \"attestation scheme\"?",
              "createdAt": "2023-05-23T07:26:18Z",
              "updatedAt": "2023-05-23T07:32:48Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe Authorization Server will communicate its requirements for the attestation scheme through its metadata. A Client instance that wants to request an access token from this Authorization Server will need to obtain a Client Attestation JWT from its client backend first. Therefore the client will generate an ephemeral key (Client Instance Key) and (platform specific) attestations to proof its genuinity and security to the client backend. The Client instance sends this data to the client backend in request for a Client Attestation JWT. If the Client Backend successfully validates the Client Instance Key and further data, it will generate a signed Client Attestation JWT. As the Client Attestation JWT is cryptographically bound to the Client Instance Key generated by the client, the attestation is bound to this particular client instance. The client backend will respond to the client's request by sending the Client Attestation JWT. The client can proceed and generate a Client Attestation Proof of Possession (PoP) for the Client Instance Key. Lastly, the client sends both the Client Attestation JWT and the Client Attestation PoP with the Token Request to the Authorization Server. The Authorization Server will validate the client attestation and thus authenticates the client. The Authorization Server may continue to issue sender-constrained access tokens using DPoP.\r\n```",
              "createdAt": "2023-05-23T07:29:18Z",
              "updatedAt": "2023-05-23T07:32:48Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n   A JSON Web Token (JWT) generated by the client backend that authenticates the client instance.\r\n```",
              "createdAt": "2023-05-23T07:30:10Z",
              "updatedAt": "2023-05-23T07:32:49Z"
            },
            {
              "originalPosition": 141,
              "body": "Why not just use the same client attestation JWT? That would not require any client instance identification and is also not a privacy issue. \r\n\r\nurn:ietf:params:oauth:client-assertion-type:jwt-key-attestation -> urn:ietf:params:oauth:client-assertion-type:jwt-client-attestation",
              "createdAt": "2023-05-23T07:32:42Z",
              "updatedAt": "2023-05-23T07:32:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WH6z9",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T03:05:32Z",
          "updatedAt": "2023-05-26T03:05:33Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "This text feels a bit more complex to me? I think the previous text was a bit clearer in this explanation?",
              "createdAt": "2023-05-26T03:05:32Z",
              "updatedAt": "2023-05-26T03:05:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WH69M",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T03:06:41Z",
          "updatedAt": "2023-05-26T03:06:42Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "schema is a bit of a loaded word here I think the JWT processing section already makes it clear AS and clients are permitted to add what ever else they wish to the JWTs\r\n```suggestion\r\nThis specification only defines the format of the Client Assertion JWT that a client instance uses to authenticate in its interactions with an authorization server (indicated in step 6), which is comprised of two key parts:\r\n```",
              "createdAt": "2023-05-26T03:06:41Z",
              "updatedAt": "2023-05-26T03:06:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WH7AZ",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T03:07:07Z",
          "updatedAt": "2023-05-26T03:07:07Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n1. A client attestation JSON Web Token (JWT)- produced by the client backend.\r\n```",
              "createdAt": "2023-05-26T03:07:07Z",
              "updatedAt": "2023-05-26T03:07:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WNC7X",
          "commit": {
            "abbreviatedOid": "2208c9a"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-26T13:40:30Z",
          "updatedAt": "2023-05-26T13:40:30Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "A well know data structure that defines the data an attestation should, shall or may, contain\r\n\r\nShould It be a defined term?\r\n",
              "createdAt": "2023-05-26T13:40:30Z",
              "updatedAt": "2023-05-26T13:40:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wf73e",
          "commit": {
            "abbreviatedOid": "346ebf2"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-05-30T15:14:03Z",
          "updatedAt": "2023-05-30T15:28:17Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "yes",
              "createdAt": "2023-05-30T15:14:03Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nNote: the protocols for obtaining Client Attestation JWTs (steps 2 and 4) is out of scope of this specification.\r\n```",
              "createdAt": "2023-05-30T15:17:05Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n1. A client attestation JWT - produced by the client backend.\r\n```",
              "createdAt": "2023-05-30T15:17:43Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 141,
              "body": "```suggestion\r\nAuthorization servers issuing a refresh token in response to a token request using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" client authentication method MUST bind the refresh token to the client instance, and NOT just the client as specified in section 6 [@!RFC6749]. To prove this binding, the client instance MUST authenticate itself to the authorization server when refreshing an access token using the \"urn:ietf:params:oauth:client-assertion-type:jwt-key-attestation\" authentication method. The client MUST also use the same Client Attestation that was used for authentication when the refresh token was issued.\r\n```",
              "createdAt": "2023-05-30T15:18:35Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nThis specification defines a new method of client authentication for OAuth 2.0 {{RFC6749}} by extending the approach defined in {{RFC7521}}. This new method enables client deployments that are traditionally viewed as public clients to be able to authenticate with the authorization server through an attestation based authentication scheme.\r\n```",
              "createdAt": "2023-05-30T15:19:28Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this mechanism to provide a way for a client instance to authenticate itself with the authorization server through an assertion that is bound to a public key (for proof of possession). This assertion is designated as Client Attestation.\r\n```",
              "createdAt": "2023-05-30T15:19:47Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe Authorization Server will communicate its requirements for the client attestation through its metadata. A Client instance that wants to request an access token from this Authorization Server will need to obtain a Client Attestation JWT from its client backend first. Therefore the client will provide attestations to proof its genuineness and security (typically obtained from the platform) along with a fresh Client Instance Key to its backend. If the Client Backend successfully validates the attestation data and the proof of possession of the Client Instance Key, it will generate a signed Client Attestation JWT that is bound to the client instance key. As the Client Attestation JWT is cryptographically bound to the Client Instance Key generated by the client, the attestation is bound to this specific client instance. The client backend will respond to the client's request with this Client Attestation JWT. The client can proceed and generate a Client Attestation Proof of Possession (PoP) for the Client Instance Key. Lastly, the client sends both the Client Attestation JWT and the Client Attestation PoP with the Token Request to the Authorization Server. The Authorization Server will validate the client attestation and thus authenticates the client instance. The Authorization Server may continue to issue sender-constrained access tokens using DPoP.\r\n```",
              "createdAt": "2023-05-30T15:25:54Z",
              "updatedAt": "2023-05-30T15:28:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WdJUe",
          "commit": {
            "abbreviatedOid": "4c0617b"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T09:10:44Z",
          "updatedAt": "2023-05-30T16:17:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Why is the Client Instance Key ephemeral? Is there an agreement that this key shall not be reused?",
              "createdAt": "2023-05-30T09:10:44Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 141,
              "body": "opened as separate issue",
              "createdAt": "2023-05-30T09:15:30Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 54,
              "body": "just wanted to clarify that its about protocols and data formats",
              "createdAt": "2023-05-30T15:01:41Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 14,
              "body": "@tlodderstedt Do you prefer schema?",
              "createdAt": "2023-05-30T15:03:43Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 54,
              "body": "outdated change",
              "createdAt": "2023-05-30T15:59:10Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            },
            {
              "originalPosition": 12,
              "body": "outdated, but approved the change in my commit",
              "createdAt": "2023-05-30T16:01:00Z",
              "updatedAt": "2023-05-30T16:17:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wgpyx",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T16:51:23Z",
          "updatedAt": "2023-05-30T16:51:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5Whmik",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:11:37Z",
          "updatedAt": "2023-05-30T19:11:38Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification extends this assertion to be bound to a public key for proof of possession. This assertion is designated as Client Attestation.\r\n```",
              "createdAt": "2023-05-30T19:11:37Z",
              "updatedAt": "2023-05-30T19:11:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Who6-",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:18:46Z",
          "updatedAt": "2023-05-30T19:18:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\nThe Authorization Server will communicate its requirements for the attestation scheme through its metadata. A Client instance that wants to request an access token from this Authorization Server will need to obtain a Client Attestation JWT, for example, from its client backend first. Therefore, the client will generate a key (Client Instance Key) and (platform specific) attestations to prove its authenticity and security to the client backend. The Client instance sends this data to the client backend in request for a Client Attestation JWT. If the Client Backend successfully validates the Client Instance Key and further data, it will generate a signed Client Attestation JWT. As the Client Attestation JWT is cryptographically bound to the Client Instance Key generated by the client, the attestation is bound to this particular client instance. The client backend will respond to the client's request by sending the Client Attestation JWT. The client can proceed and generate a Client Attestation Proof of Possession (PoP) for the Client Instance Key. Lastly, the client sends both the Client Attestation JWT and the Client Attestation PoP with the Token Request to the Authorization Server. The Authorization Server will validate the client attestation and thus authenticates the client. The Authorization Server may continue to issue sender-constrained access tokens using {{oauth-dpop-16}}.\r\n```\r\n\r\nwhat is `(platform specific) attestation` ?\r\nplease be consistent, capitalize `Client` everywhere or not capitalize it.\r\nthe explanation is pretty long. I would suggest to put a short summary before the diagram but break down this paragraph into the steps and put them under the diagram.",
              "createdAt": "2023-05-30T19:18:46Z",
              "updatedAt": "2023-05-30T19:18:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Whpcu",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:20:07Z",
          "updatedAt": "2023-05-30T19:20:07Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n   A cryptographic, asymmetric key generated by the client instance and proven to the client backend. The public key is contained in the Client Attestation JWT and is used to sign the Client Attestation Proof of Possession.\r\n```",
              "createdAt": "2023-05-30T19:20:07Z",
              "updatedAt": "2023-05-30T19:20:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WhrvT",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:24:48Z",
          "updatedAt": "2023-05-30T19:24:49Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I perceive this draft as a PoP version of `urn:ietf:params:oauth:grant-type:jwt-bearer`, would it make sense to make that more intuitive and explicit - like `urn:ietf:params:oauth:grant-type:jwt-pop`?",
              "createdAt": "2023-05-30T19:24:48Z",
              "updatedAt": "2023-05-30T19:24:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Whr_p",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T19:25:31Z",
          "updatedAt": "2023-05-30T19:25:31Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nThe following rules apply to validating the Client Attestation JWT. Application of additional restrictions and policy are at the discretion of the Authorization Server.\r\n```\r\nClient Attestation JWT or Client Attestation PoP JWT?\r\nalso capitalization - please be consistent...",
              "createdAt": "2023-05-30T19:25:31Z",
              "updatedAt": "2023-05-30T19:25:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WhuCq",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "a new paragraph in intro sectionis great but hard to follow, suggest to break it down into steps and put under the diagram.\r\n\r\nI also perceive this draft as a PoP version of urn:ietf:params:oauth:grant-type:jwt-bearer, would it make sense to make that more intuitive and explicit - like urn:ietf:params:oauth:grant-type:jwt-pop? - this can be another issue",
          "createdAt": "2023-05-30T19:30:39Z",
          "updatedAt": "2023-05-30T19:30:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5WiY_v",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:35:53Z",
          "updatedAt": "2023-05-30T21:35:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Just noting that given we now have OAuth 2.1 saying this is for OAuth 2.0 might give the wrong compatibility impression?",
              "createdAt": "2023-05-30T21:35:53Z",
              "updatedAt": "2023-05-30T21:35:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiZdE",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:37:44Z",
          "updatedAt": "2023-05-30T21:37:45Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\n{{RFC7521}} defines a way for a client to include an assertion in a token request to an authorization server for the purposes of client authentication. This specification uses this framework to define a new assertion type that provides a way for a client instance to authenticate itself with the authorization server through an assertion that is bound to a public key (for proof of possession). This assertion is designated with the name of Client Attestation in this draft.\r\n```",
              "createdAt": "2023-05-30T21:37:45Z",
              "updatedAt": "2023-05-30T21:37:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiZhJ",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:37:56Z",
          "updatedAt": "2023-05-30T21:37:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@tlodderstedt originally made this change",
              "createdAt": "2023-05-30T21:37:56Z",
              "updatedAt": "2023-05-30T21:37:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiZxZ",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:38:57Z",
          "updatedAt": "2023-05-30T21:38:58Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Kind of conflicts with @Sakurann review, we don't extend the assertion we extend the framework or mechanism defined by RFC 7521.",
              "createdAt": "2023-05-30T21:38:57Z",
              "updatedAt": "2023-05-30T21:38:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WiaUS",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:41:08Z",
          "updatedAt": "2023-05-30T21:41:08Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Communication of this requirement may be communicated via metadata I dont think that is the only way though and would prefer we dont imply this. I'd also prefer we dont talk much about how the attestation is obtained by the client instance, much of this paragraph to me is informational and might set the wrong tone for the draft in terms of prescribing a solution.",
              "createdAt": "2023-05-30T21:41:08Z",
              "updatedAt": "2023-05-30T21:41:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wiaxg",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:42:58Z",
          "updatedAt": "2023-05-30T21:42:58Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Client Attestation JWT is from the terminology, so I capitalize it, other occurences are not in the Terminology (yet), so therefore not capitalized, that should be consistent for now",
              "createdAt": "2023-05-30T21:42:58Z",
              "updatedAt": "2023-05-30T21:42:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WibEh",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:44:12Z",
          "updatedAt": "2023-05-30T21:44:13Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Still prefer the previous language to be honest, data exchanged is a part of the protocol IMO and its one protocol not multiple hence protocol instead of protocols. The diagram also already describes what is happening so the \"request and sending a client attestation JWT\" feels redundant.  ",
              "createdAt": "2023-05-30T21:44:13Z",
              "updatedAt": "2023-05-30T21:44:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5Wibc-",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-30T21:45:41Z",
          "updatedAt": "2023-05-30T21:45:42Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Im not against this but I think it makes it less clear how it relates to the terminology we have established in the draft e.g this means the type would be ^ but the name of is client attestation?",
              "createdAt": "2023-05-30T21:45:41Z",
              "updatedAt": "2023-05-30T21:45:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WjLPB",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "tlodderstedt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-05-31T01:19:24Z",
          "updatedAt": "2023-05-31T01:19:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "we don't have OAuth 2.1 yet, it's a draft. But I would be fine with just \"OAuth\" (with the existing reference to RFC 6749",
              "createdAt": "2023-05-31T01:19:25Z",
              "updatedAt": "2023-05-31T01:19:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5WvdSt",
          "commit": {
            "abbreviatedOid": "bc84403"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-01T11:53:46Z",
          "updatedAt": "2023-06-01T11:53:46Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I agree with @tplooker and like the emphasis on client instance",
              "createdAt": "2023-06-01T11:53:46Z",
              "updatedAt": "2023-06-01T11:53:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XJS5l",
          "commit": {
            "abbreviatedOid": "1d893d1"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T08:55:36Z",
          "updatedAt": "2023-06-05T08:55:37Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "I agree with @tplooker , as that could lead to confusion. But no hard feelings here",
              "createdAt": "2023-06-05T08:55:36Z",
              "updatedAt": "2023-06-05T08:55:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XKsZi",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-06-05T12:28:16Z",
          "updatedAt": "2023-06-05T12:35:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "does the status of \"public clients\" be applied also in this case?\r\n\r\nI've the perception that in our use cases whatever are the statuses of the clients is not relevant to this draft",
              "createdAt": "2023-06-05T12:28:16Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 53,
              "body": "I'd write using present, removing \"will\"\r\n\r\nWDYT about\r\n\r\n`The flow starts with the AS communicating its requirements for the client authentication to the client, made available in its metadata.`\r\n\r\nHaving said \"the AS\" that would be the same for the Client as well, thus\r\n\r\n`The Client instance makes available its Client Attestation JWS to the AS where an access token is requested`",
              "createdAt": "2023-06-05T12:33:18Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 56,
              "body": "I'd not use the future, I think that would be better talking in the present",
              "createdAt": "2023-06-05T12:34:03Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 56,
              "body": "`client instance` -> `Client instance`",
              "createdAt": "2023-06-05T12:34:32Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 56,
              "body": "is client backend a defined term? If yes, we should uppercase it accordingly",
              "createdAt": "2023-06-05T12:35:10Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            },
            {
              "originalPosition": 60,
              "body": "will validate -> valitades",
              "createdAt": "2023-06-05T12:35:32Z",
              "updatedAt": "2023-06-05T12:35:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XK2G8",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T12:48:39Z",
          "updatedAt": "2023-06-05T12:48:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "the clients being authenticated by the approach of this RFC, are to be considered public clients in OAuth speak. Doesn't it make sense to say so?",
              "createdAt": "2023-06-05T12:48:39Z",
              "updatedAt": "2023-06-05T12:48:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XK68l",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T12:56:53Z",
          "updatedAt": "2023-06-05T12:56:54Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "I will capitalize things later once they have an entry in the terminology",
              "createdAt": "2023-06-05T12:56:53Z",
              "updatedAt": "2023-06-05T12:56:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XK8Ea",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T12:59:19Z",
          "updatedAt": "2023-06-05T12:59:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I'm ok with public client since wallet instances are mobile devices, I was just asking since I read in the specs also the role of client backend without knowing which would be their client registration mechanisms",
              "createdAt": "2023-06-05T12:59:19Z",
              "updatedAt": "2023-06-05T12:59:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XLDS9",
          "commit": {
            "abbreviatedOid": "6ac2b5c"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T13:14:55Z",
          "updatedAt": "2023-06-05T13:14:56Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "changed all introduction text to present",
              "createdAt": "2023-06-05T13:14:55Z",
              "updatedAt": "2023-06-05T13:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XLjSU",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-05T14:11:19Z",
          "updatedAt": "2023-06-05T14:11:19Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I approve this PR with this in mind\r\n\r\nClient Instance, as represented in the Figure 1, should be a defined term as well",
              "createdAt": "2023-06-05T14:11:19Z",
              "updatedAt": "2023-06-05T14:11:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XLjUZ",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "peppelinux",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-05T14:11:23Z",
          "updatedAt": "2023-06-05T14:11:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5XYPNF",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T19:56:39Z",
          "updatedAt": "2023-06-06T19:56:40Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "This paragraph reads like there is a dependency on an AS providing a metadata document for a client to discover when in reality a client could know through an out of band mechanism that its what the AS requires for client authentication",
              "createdAt": "2023-06-06T19:56:39Z",
              "updatedAt": "2023-06-06T19:56:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYPyC",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T19:58:20Z",
          "updatedAt": "2023-06-06T19:58:21Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Again I'm wary of describing the usage of platform attestations in this draft even in a non-normative manner as this mechanism of client authentication is agnostic to these sorts of things, perhaps we should put this in an appendix?",
              "createdAt": "2023-06-06T19:58:20Z",
              "updatedAt": "2023-06-06T19:58:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYS8R",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T20:03:25Z",
          "updatedAt": "2023-06-06T20:03:26Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "```suggestion\r\n   A JSON Web Token (JWT) generated by the client backend which is bound to a key managed by a client instance which can then be used by the instance for client authentication.\r\n```",
              "createdAt": "2023-06-06T20:03:25Z",
              "updatedAt": "2023-06-06T20:03:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYo5Q",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T20:45:21Z",
          "updatedAt": "2023-06-06T20:45:22Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "```suggestion\r\nClient Attestation Proof of Possession (PoP) JWT\r\n```",
              "createdAt": "2023-06-06T20:45:21Z",
              "updatedAt": "2023-06-06T20:45:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5XYpF0",
          "commit": {
            "abbreviatedOid": "36bf2bf"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-06T20:45:53Z",
          "updatedAt": "2023-06-06T20:45:53Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "```suggestion\r\n   A Proof of Possession generated by the client instance using the key that the Client Attestation JWT is bound to.\r\n```",
              "createdAt": "2023-06-06T20:45:53Z",
              "updatedAt": "2023-06-06T20:45:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOJaEkaM5YF6J7",
          "commit": {
            "abbreviatedOid": "8825f3f"
          },
          "author": "Sakurann",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I would like to see the description under the sequence diagram improved, but if you want to address that in another PR, that is fine too.",
          "createdAt": "2023-06-13T19:45:05Z",
          "updatedAt": "2023-06-13T19:45:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 16,
      "id": "PR_kwDOJaEkaM5RtQi2",
      "title": "adding myself as author",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/pull/16",
      "state": "MERGED",
      "author": "paulbastian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-30T17:12:40Z",
      "updatedAt": "2023-05-30T19:07:33Z",
      "baseRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "baseRefName": "main",
      "baseRefOid": "071f2a30565a4428394ab157325fffd212a47277",
      "headRepository": "paulbastian/draft-looker-oauth-attested-key-based-client-authentication",
      "headRefName": "editor",
      "headRefOid": "6461cabfe5388ffb6f8de6c9d8ae956ce6c8cc5b",
      "closedAt": "2023-05-30T19:07:33Z",
      "mergedAt": "2023-05-30T19:07:33Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "3006a80ffa8a5375a1d0fc277a93432b29c3409d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5Whktc",
          "commit": {
            "abbreviatedOid": "6461cab"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T19:07:27Z",
          "updatedAt": "2023-05-30T19:07:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 19,
      "id": "PR_kwDOJaEkaM5S7FXz",
      "title": "Simplifies introduction",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/pull/19",
      "state": "OPEN",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Re-simplifies the introduction ",
      "createdAt": "2023-06-13T19:52:21Z",
      "updatedAt": "2023-06-27T20:45:25Z",
      "baseRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "baseRefName": "main",
      "baseRefOid": "0d942cf0688ed99afccfb16c850bb5ff7b62bfc3",
      "headRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "tl/simplify-intro",
      "headRefOid": "2ff3c8cd02361c4d7471a873635da3c78419d4bd",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5Zg2lf",
          "commit": {
            "abbreviatedOid": "2ff3c8c"
          },
          "author": "selfissued",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I agree with this direction.  I would try to eliminate places where the spec appears to be make normative statements about having a backend.  (It's fine to say things like \"1. A Client Attestation JWT - typically produced by the client backend.\")",
          "createdAt": "2023-06-27T20:21:36Z",
          "updatedAt": "2023-06-27T20:21:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5Zg-Ej",
          "commit": {
            "abbreviatedOid": "2ff3c8c"
          },
          "author": "c2bo",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-27T20:45:25Z",
          "updatedAt": "2023-06-27T20:45:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 21,
      "id": "PR_kwDOJaEkaM5TggJG",
      "title": "Renames the draft",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/pull/21",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Renames the draft as per the previous conversation in #11 ",
      "createdAt": "2023-06-21T06:32:21Z",
      "updatedAt": "2023-06-21T06:34:30Z",
      "baseRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "baseRefName": "main",
      "baseRefOid": "0d942cf0688ed99afccfb16c850bb5ff7b62bfc3",
      "headRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "tl/rename-draft",
      "headRefOid": "e353a6a5f1e289d2a11df5448c3081b6576c5811",
      "closedAt": "2023-06-21T06:34:30Z",
      "mergedAt": "2023-06-21T06:34:30Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "c41f00ee49ceaf65aac6d2b1ab85dc5cb8ba41a3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5YzYDI",
          "commit": {
            "abbreviatedOid": "e353a6a"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-21T06:34:20Z",
          "updatedAt": "2023-06-21T06:34:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 22,
      "id": "PR_kwDOJaEkaM5TscnY",
      "title": "fix: small typos in the diagram",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/pull/22",
      "state": "MERGED",
      "author": "peppelinux",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "<!-- If this pull request closes an issue, please mention the issue number below -->\r\nCloses # <!-- Issue # here -->\r\n\r\n## \ud83d\udcd1 Description\r\n<!-- Add a brief description of the pr -->\r\n\r\n<!-- You can also choose to add a list of changes and if they have been completed or not by using the markdown to-do list syntax\r\n- [ ] Not Completed\r\n- [x] Completed\r\n-->\r\n\r\n## Preview Link\r\n\r\n<!-- Update the link below to provide reviewers with a convenient link to view a rendered version of the PR-->\r\n<!-- In general the link should be of the form https://github.com/<repo-name>/<branch-name>/<draft-name>.html-->\r\n\r\n[click here for rendered preview of PR](https://github.com/<repo-name>/<branch-name>/<draft-name>.html)",
      "createdAt": "2023-06-22T21:06:40Z",
      "updatedAt": "2023-06-26T20:21:30Z",
      "baseRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "baseRefName": "main",
      "baseRefOid": "4e37428fbe7d51eca28fb8f78b0670460281b321",
      "headRepository": "peppelinux/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "patch-1",
      "headRefOid": "e7d8b3dc2cc3a791280f2e84792dff07a6868a7a",
      "closedAt": "2023-06-26T20:21:30Z",
      "mergedAt": "2023-06-26T20:21:30Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "8d559493b23cbfbb31dc36f055d021727a39ae8b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOJaEkaM5ZPXzv",
          "commit": {
            "abbreviatedOid": "e7d8b3d"
          },
          "author": "paulbastian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-25T21:59:52Z",
          "updatedAt": "2023-06-25T21:59:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOJaEkaM5ZXmvU",
          "commit": {
            "abbreviatedOid": "e7d8b3d"
          },
          "author": "tplooker",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-26T20:21:18Z",
          "updatedAt": "2023-06-26T20:21:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 23,
      "id": "PR_kwDOJaEkaM5UEiST",
      "title": "add 2.0 to be consistent with other oauth drafts",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/pull/23",
      "state": "MERGED",
      "author": "tplooker",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "## \ud83d\udcd1 Description\r\n\r\nFixes some minor typos",
      "createdAt": "2023-06-27T19:20:08Z",
      "updatedAt": "2023-06-27T19:20:56Z",
      "baseRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "baseRefName": "main",
      "baseRefOid": "c797daf4f099359bcc04229d9e92e3fa1f224f35",
      "headRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "tl/rename-draft",
      "headRefOid": "c4c448cb447c9f393b44ac00e5031d8445588085",
      "closedAt": "2023-06-27T19:20:16Z",
      "mergedAt": "2023-06-27T19:20:16Z",
      "mergedBy": "tplooker",
      "mergeCommit": {
        "oid": "bfc14dddcc864efe25d201159abfedddc08a7496"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 25,
      "id": "PR_kwDOJaEkaM5UFpJH",
      "title": "Mike's pre-publication suggestions",
      "url": "https://github.com/vcstuff/draft-looker-oauth-attestation-based-client-authentication/pull/25",
      "state": "OPEN",
      "author": "selfissued",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Closes #24",
      "createdAt": "2023-06-28T00:13:26Z",
      "updatedAt": "2023-06-28T00:13:27Z",
      "baseRepository": "vcstuff/draft-looker-oauth-attestation-based-client-authentication",
      "baseRefName": "main",
      "baseRefOid": "a09c6e079f6fae416a8ac451fdea7ce987884fad",
      "headRepository": "selfissued/draft-looker-oauth-attestation-based-client-authentication",
      "headRefName": "mbj-pre-publication-suggestions",
      "headRefOid": "c6d649d285643da868cae9984655345db9c05a11",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    }
  ]
}